package org.mjdev.balldontlie.base.navigation

import androidx.annotation.CallSuper
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.unit.sp
import androidx.navigation.NamedNavArgument
import androidx.navigation.NavBackStackEntry
import androidx.navigation.NavHostController
import org.mjdev.balldontlie.R
import org.mjdev.balldontlie.base.annotations.DayPreview
import org.mjdev.balldontlie.base.helpers.Ext.currentRoute
import org.mjdev.balldontlie.base.helpers.Ext.previewData
import kotlin.reflect.full.createInstance

/**
 * Screen class.
 *
 * This is base of all screens in application and auto creation of route and nav graph.
 * This object represents one screen at time.
 * Can contain menu that is exported to navigation drawer.
 *
 * @constructor Create empty constructor for screen
 */
open class Screen {

    /**
     * Autogenerated path / route
     */
    private val routeBase: String
        get() = this::class.simpleName ?: "-"

    /**
     * Complete autogenerated path / route with parameters
     */
    val completeRoute: String
        get() = routeBase.let { rb ->
            var routeImpl = rb
            args.forEach { arg ->
                routeImpl = routeImpl.plus("${arg.name}={${arg.name}}")
            }
            routeImpl
        }

    /**
     * Screen title
     */
    open val titleResId: Int = R.string.app_name

    /**
     * Screen arguments if any
     */
    open val args: List<NamedNavArgument> = emptyList()

    /**
     * Menu string resource id
     * menu is generated only if it returns id > 0
     */
    open val menuResId: Int = -1

    /**
     * Menu icon if any
     */
    open val menuIcon: ImageVector? = null

    /**
     * Autogenerated menu item, if any
     * Generated only if [menuResId] > 0
     */
    val menuItem get() = if (menuResId >= 0) MenuItem(menuResId, menuIcon, completeRoute)
    else null

    /**
     * Compose function.
     *
     * Helper function to preview without parameters as preview of compose needed.
     *
     * @return
     */
    @DayPreview
    @Composable
    @CallSuper
    open fun Compose() = Compose(null, null, emptyList())

    /**
     * Compose function for compose screen.
     * This should be only a method overriden in super classes.
     *
     * @param navController Nav controller
     * @param backStackEntry Back stack entry
     * @param menuItems Menu items
     */
    @Composable
    open fun Compose(
        navController: NavHostController?,
        backStackEntry: NavBackStackEntry?,
        menuItems: List<MenuItem>
    ) {

        Column(
            modifier = previewData(Modifier) {
                Modifier.fillMaxSize()
            },
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Empty Screen",
                fontSize = 24.sp
            )
        }

    }

    companion object {

        /**
         * Open screen extension.
         *
         * Function opens a screen with parameters given, if any,
         * from another screen.
         *
         * @param navController Nav controller
         * @param values Values
         * @param T T
         */
        inline fun <reified T : Screen> open(
            navController: NavHostController?,
            vararg values: Any?
        ) {
            val instance = T::class.createInstance()
            instance.completeRoute.let { r ->
                var routeImpl = r
                instance.args.forEachIndexed { idx, arg ->
                    routeImpl = routeImpl.replace(
                        "{${arg.name}}",
                        (values[idx] ?: "").toString()
                    )
                }
                routeImpl
            }.also { finalRoute ->
                val currentRoute = navController?.currentRoute
                val equals = currentRoute?.equals(finalRoute)
                if (equals != true) {
                    navController?.navigate(finalRoute)
                }
            }
        }

        /**
         * Open route.
         *
         * @param route Route
         * @receiver [NavHostController]
         */
        fun NavHostController.open(route: String) {
            val equals = currentRoute?.equals(route)
            if (equals != true) {
                navigate(route)
            }
        }

    }

}